// Package kogagent â€” PlannerAgent decomposes a high-level goal into ordered
// sub-tasks and executes them, optionally using sub-agents.
package kogagent

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"sync"
	"time"

	"github.com/p-blackswan/platform-agent/internal/event"
	"github.com/p-blackswan/platform-agent/internal/llm"
	"github.com/p-blackswan/platform-agent/internal/memory"
	"github.com/p-blackswan/platform-agent/internal/tool"
)

// Task is a single unit of work in a plan.
type Task struct {
	ID          string        `json:"id"`
	Description string        `json:"description"`
	Status      TaskStatus    `json:"status"`
	Result      string        `json:"result,omitempty"`
	Error       string        `json:"error,omitempty"`
	StartedAt   time.Time     `json:"started_at,omitempty"`
	FinishedAt  time.Time     `json:"finished_at,omitempty"`
}

// TaskStatus tracks a task's lifecycle.
type TaskStatus string

const (
	TaskStatusPending  TaskStatus = "pending"
	TaskStatusRunning  TaskStatus = "running"
	TaskStatusDone     TaskStatus = "done"
	TaskStatusFailed   TaskStatus = "failed"
	TaskStatusSkipped  TaskStatus = "skipped"
)

// Plan is an ordered list of tasks generated by the planner LLM call.
type Plan struct {
	Goal  string  `json:"goal"`
	Tasks []Task  `json:"tasks"`
}

// PlannerSpec configures a PlannerAgent.
type PlannerSpec struct {
	Identity    AgentIdentity
	Provider    llm.LLMProvider
	Registry    *tool.Registry
	Memory      memory.MemoryStore
	Logger      *slog.Logger
	MaxToolIter int
	// MaxParallelTasks sets how many tasks may run in parallel.
	// 0 or 1 = sequential (default).
	MaxParallelTasks int
}

// PlannerAgent is an agent that:
// 1. Calls the LLM to decompose the incoming event into a Plan (JSON list of tasks).
// 2. Executes each task via a child baseAgent loop.
// 3. Reports the final plan status back to memory.
type PlannerAgent struct {
	spec   PlannerSpec
	logger *slog.Logger
	mu     sync.Mutex
	status Status
}

// NewPlannerAgent creates a PlannerAgent from a PlannerSpec.
func NewPlannerAgent(spec PlannerSpec) (*PlannerAgent, error) {
	if spec.Provider == nil {
		return nil, fmt.Errorf("planner: LLMProvider is required")
	}
	if err := spec.Identity.Validate(); err != nil {
		return nil, fmt.Errorf("planner: identity: %w", err)
	}
	if spec.MaxToolIter == 0 {
		spec.MaxToolIter = 10
	}
	if spec.MaxParallelTasks <= 0 {
		spec.MaxParallelTasks = 1
	}
	logger := spec.Logger
	if logger == nil {
		logger = slog.Default()
	}
	return &PlannerAgent{spec: spec, logger: logger, status: StatusIdle}, nil
}

// ID returns the planner's agent ID.
func (p *PlannerAgent) ID() string { return p.spec.Identity.ID }

// Status returns the planner's current status.
func (p *PlannerAgent) Status() Status {
	p.mu.Lock()
	defer p.mu.Unlock()
	return p.status
}

func (p *PlannerAgent) setStatus(s Status) {
	p.mu.Lock()
	p.status = s
	p.mu.Unlock()
}

// Handle processes an event by planning and executing tasks.
func (p *PlannerAgent) Handle(ctx context.Context, ev event.Event) error {
	p.setStatus(StatusRunning)
	defer p.setStatus(StatusIdle)

	p.logger.Info("planner handling event",
		"agent", p.spec.Identity.ID,
		"event_id", ev.ID,
	)

	plan, err := p.buildPlan(ctx, ev)
	if err != nil {
		p.setStatus(StatusError)
		return fmt.Errorf("planner %s: build plan: %w", p.spec.Identity.ID, err)
	}

	p.logger.Info("plan built",
		"agent", p.spec.Identity.ID,
		"goal", plan.Goal,
		"tasks", len(plan.Tasks),
	)

	if err := p.executePlan(ctx, plan); err != nil {
		p.setStatus(StatusError)
		return fmt.Errorf("planner %s: execute plan: %w", p.spec.Identity.ID, err)
	}

	// Persist plan summary to memory.
	if p.spec.Memory != nil {
		summary := p.planSummary(plan)
		_ = p.spec.Memory.Save(ctx, memory.MemoryEntry{
			AgentID: p.spec.Identity.ID,
			Content: summary,
			Tags:    []string{"plan", ev.Source, ev.Type},
		})
	}

	p.logger.Info("planner done", "agent", p.spec.Identity.ID, "event_id", ev.ID)
	return nil
}

// planningSystemPrompt returns the system prompt for the planning step.
var planningSystemPrompt = `You are a planning agent. Given a goal or request, decompose it into a minimal, ordered list of concrete tasks.

Respond ONLY with valid JSON in this exact format (no markdown, no explanation):
{
  "goal": "<one-line summary of what needs to be done>",
  "tasks": [
    {"id": "t1", "description": "<clear, self-contained task description>", "status": "pending"},
    {"id": "t2", "description": "<next task>", "status": "pending"}
  ]
}

Rules:
- Each task must be independently executable.
- Keep tasks atomic: one clear action per task.
- Maximum 10 tasks per plan.
- IDs must be unique strings like t1, t2, ...`

// buildPlan calls the LLM to decompose the event into a plan.
func (p *PlannerAgent) buildPlan(ctx context.Context, ev event.Event) (*Plan, error) {
	userMsg := fmt.Sprintf("Goal/request:\n[Event: source=%s type=%s id=%s]\n%s",
		ev.Source, ev.Type, ev.ID, string(ev.Payload))

	resp, err := p.spec.Provider.Complete(ctx, llm.CompletionRequest{
		SystemPrompt: planningSystemPrompt,
		Messages: []llm.Message{
			{Role: llm.RoleUser, Content: userMsg},
		},
	})
	if err != nil {
		return nil, fmt.Errorf("planning llm call: %w", err)
	}

	var plan Plan
	if err := json.Unmarshal([]byte(resp.Text), &plan); err != nil {
		// If JSON parsing fails, create a single-task fallback plan.
		p.logger.Warn("planner: could not parse plan JSON, using fallback",
			"agent", p.spec.Identity.ID,
			"text", resp.Text[:min(200, len(resp.Text))],
			"err", err,
		)
		plan = Plan{
			Goal: string(ev.Payload),
			Tasks: []Task{
				{ID: "t1", Description: resp.Text, Status: TaskStatusPending},
			},
		}
	}
	return &plan, nil
}

// executePlan runs all tasks in the plan, respecting MaxParallelTasks.
func (p *PlannerAgent) executePlan(ctx context.Context, plan *Plan) error {
	if p.spec.MaxParallelTasks <= 1 {
		// Sequential execution.
		for i := range plan.Tasks {
			p.executeTask(ctx, &plan.Tasks[i])
		}
		return nil
	}

	// Parallel execution with semaphore.
	sem := make(chan struct{}, p.spec.MaxParallelTasks)
	var wg sync.WaitGroup
	for i := range plan.Tasks {
		task := &plan.Tasks[i]
		sem <- struct{}{}
		wg.Add(1)
		go func() {
			defer wg.Done()
			defer func() { <-sem }()
			p.executeTask(ctx, task)
		}()
	}
	wg.Wait()
	return nil
}

// executeTask runs a single task via the baseAgent LLM+tool loop.
func (p *PlannerAgent) executeTask(ctx context.Context, task *Task) {
	task.Status = TaskStatusRunning
	task.StartedAt = time.Now().UTC()

	p.logger.Info("executing task",
		"planner", p.spec.Identity.ID,
		"task_id", task.ID,
		"desc", task.Description,
	)

	// Build a child agent for this task.
	childSpec := Spec{
		ID:           fmt.Sprintf("%s.%s", p.spec.Identity.ID, task.ID),
		SystemPrompt: p.spec.Identity.SystemPrompt(),
		Provider:     p.spec.Provider,
		Registry:     p.spec.Registry,
		Memory:       p.spec.Memory,
		Logger:       p.logger,
		MaxToolIter:  p.spec.MaxToolIter,
	}
	agent, err := New(childSpec)
	if err != nil {
		task.Status = TaskStatusFailed
		task.Error = fmt.Sprintf("create child agent: %v", err)
		task.FinishedAt = time.Now().UTC()
		return
	}

	// Create a synthetic event for this task.
	taskPayload, _ := json.Marshal(map[string]string{
		"task_id":     task.ID,
		"description": task.Description,
		"plan_goal":   "",
	})
	taskEv := event.Event{
		ID:        fmt.Sprintf("task_%s_%s", p.spec.Identity.ID, task.ID),
		Source:    event.SourceInternal,
		Type:      "task",
		Payload:   taskPayload,
		Timestamp: time.Now().UTC(),
	}

	if err := agent.Handle(ctx, taskEv); err != nil {
		task.Status = TaskStatusFailed
		task.Error = err.Error()
	} else {
		task.Status = TaskStatusDone
	}
	task.FinishedAt = time.Now().UTC()
}

// planSummary returns a concise string summary of plan execution.
func (p *PlannerAgent) planSummary(plan *Plan) string {
	done, failed, skipped := 0, 0, 0
	for _, t := range plan.Tasks {
		switch t.Status {
		case TaskStatusDone:
			done++
		case TaskStatusFailed:
			failed++
		case TaskStatusSkipped:
			skipped++
		}
	}
	return fmt.Sprintf("[Plan] goal=%q tasks=%d done=%d failed=%d skipped=%d",
		plan.Goal, len(plan.Tasks), done, failed, skipped)
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
